/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;
  //debug_parser = true;}PARSER_BEGIN(EG1)
import java.util.*;

public class EG1{
  static int tempCounter, symbolCounter, nestingLevel, offset;
  private static VerboseStack stack, breakStack, contStack, offsetStack;
  public static VerboseStack blockStack;
  private static ArrayList<ExtendedQuad> eQuadList;
  static ArrayList<Symbol> symbolTable;
  private static ArrayList<Integer> basicBlockStarts;
    public static void main(String args []) throws ParseException  {    EG1 parser = new EG1(System.in);    while (true)    {
      stack = new VerboseStack();
      breakStack = new VerboseStack();
      blockStack = new VerboseStack();
      blockStack.push("block0");
      offsetStack = new VerboseStack();
      contStack = new VerboseStack();
      eQuadList = new ArrayList<ExtendedQuad>();
      symbolTable = new ArrayList<Symbol>();
      basicBlockStarts = new ArrayList<Integer>();
      tempCounter = 1;
      symbolCounter = 1;
      nestingLevel = 0;
      offset = 0;      System.out.println("Reading from standard input...");      System.out.print("$ > ");      try      {        if (EG1.program())        {
          System.out.println("\n- Extended QuadList -");
		  int i = 0;
		  for (ExtendedQuad q : eQuadList)
		  {
			if (i == 0)
			{
			  basicBlockStarts.add(i);
			}
			else if ("jump".equals(q.getOperator()))
			{
			  int next = Integer.parseInt(q.getResult().getName());
			  if (basicBlockStarts.indexOf(next) == -1)
		  	  {
		  	    basicBlockStarts.add(next);
		  	  }
			}
			else if ("jeqz".equals(q.getOperator()))
			{
			  int next = Integer.parseInt(q.getResult().getName());
			  if (basicBlockStarts.indexOf(next) == -1)
			  {
			    basicBlockStarts.add(next);
			  }
			  if (i+1 < eQuadList.size()-1 && basicBlockStarts.indexOf(i+1) == -1) basicBlockStarts.add(i+1);
			}
		    System.out.println(i++ + ") " + q.toString());
		  }
	
		  Collections.sort(basicBlockStarts);
	
		  System.out.println("\n- Basic Block Starts  -");
		  for (Integer in : basicBlockStarts)
		  {
		    System.out.println(in.toString());
		  }
	
		  Collections.reverse(basicBlockStarts);
		  for (int x = 0; x < basicBlockStarts.size()-1; x++)
		  {
		    int quadNum = basicBlockStarts.get(x) - 1;
		    int nextStart = basicBlockStarts.get(x+1);
		    while (quadNum >= 0 && quadNum >= nextStart)
		    {
		      Field b = eQuadList.get(quadNum).getArg1();
		      Field c = eQuadList.get(quadNum).getArg2();
		      Field a = eQuadList.get(quadNum).getResult();
		      if (a.isPtr())
		      {
		        a.setNextUse(symbolTable.get(a.getSymbolTablePtr()).getNextUse());
		        symbolTable.get(a.getSymbolTablePtr()).setNextUse(0);
		      }
	
		      if (b.isPtr())
		      {
		      	b.setNextUse(symbolTable.get(b.getSymbolTablePtr()).getNextUse());
		      	symbolTable.get(b.getSymbolTablePtr()).setNextUse(quadNum);
		      }
	
		      if (c.isPtr())
		      {
		      	c.setNextUse(symbolTable.get(c.getSymbolTablePtr()).getNextUse());
		      	symbolTable.get(c.getSymbolTablePtr()).setNextUse(quadNum);
		      }
	
		      quadNum--;
		    }
		    System.out.println("\n- Symbol Table for BB (Quad#" + (quadNum+1) + " to Quad#" + (basicBlockStarts.get(x)-1) + ") -");
			int ii = 0;
			for (Symbol s : symbolTable)
			{
			  System.out.println(ii++ + ") " + s.toString());
			  s.setNextUse(-1);
			}
		  }
	
		  System.out.println("\n- Stack -");
		  for (Object o : stack)
		  {
			System.out.println(o);
		  }
	
		  if (stack.size() == 0)
		  	System.out.println("empty");          System.out.println("OK.");        }      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        EG1.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* CHARACTERS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < MOD : "%" >
| < NOT : "!" >
| < EQ : "=" >
| < DEQ : "==" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < LT : "<" >
| < GT : ">" >
| < QMARK : "?" >
| < OR : "|" >
| < AND : "&" >
| < COLON : ":" >
| < SEMI : ";" >}

TOKEN : /* RESERVED WORDS */
{  < BREAK : "break" >
| < CONT : "continue" >
| < ELSE : "else" >
| < IF : "if" >
| < RET : "return" >
| < WHILE : "while" >
| < FN : "function" >
}TOKEN :{
  < #LETTER : ["A"-"z"] >
| < #DIGIT : [ "0"-"9" ] >
| < INT : (< DIGIT >)+ > 
| < ID : < LETTER >(< LETTER > | < DIGIT >)* >}
boolean program() :
{}
{	< LBRACE > (function())* (statement())* < RBRACE >
	{
	  
	  
	  return true;
	}
}

void function() :
{
  Token name;
}{
	try	{		< FN > name=< ID >
		{
		  symbolTable.add(new Symbol(name.image, "MAIN", 0, -1, -1, -1));		}
		< LPAREN > [ < ID > ] < RPAREN > compound_statement()
	}
	catch (ParseException e)	{
	  errorSkipTo(RBRACE);
	}}

void statement() :
{
  int nextQuad;
  Object o, p;
}
{
	try	{	  compound_statement()
	}
	catch (ParseException e)
	{
	  errorSkipBlock();
	}
|	try	{	  	< WHILE >		{
		  stack.push(eQuadList.size());
		  contStack.push(eQuadList.size());		}
		test()		{
		  o = stack.pop();
		  stack.push(eQuadList.size());
		  breakStack.push(eQuadList.size());
		  eQuadList.add(new ExtendedQuad("jeqz", o.toString(), null, -1, -1));		}
		statement()
		{
		  o = stack.pop();
		  p = stack.pop();
		  eQuadList.add(new ExtendedQuad("jump", null, null, p.toString(), -1));
		  int whileJump = eQuadList.size();
	
		  int x = (int) breakStack.pop();
		  while (x != -1)
		  {
		    ExtendedQuad eq = eQuadList.get(x);
		    x = Integer.parseInt(eq.getResult().getName());
		    eq.setResult(new Field(whileJump+""));		  }
	
		  contStack.pop();		}
	}
	catch (ParseException e)
	{
	  errorSkipBlock();	}
|	< IF > test()	{
	  nextQuad = eQuadList.size();
	  o = stack.pop();
	  eQuadList.add(new ExtendedQuad("jeqz", o.toString(), null, null, -1));
	  stack.push(nextQuad);	}
	statement() [ < ELSE >	{
	  nextQuad = eQuadList.size();
	  eQuadList.add(new ExtendedQuad("jump", null, null, null, -1));
	  o = stack.pop();
	  eQuadList.get((int) o).setResult(new Field(""+(nextQuad+1), -1, -1, false));
	  stack.push(nextQuad);	}
	statement() ]
	{
	  o = stack.pop();
	  eQuadList.get((int) o).setResult(new Field(eQuadList.size()+"", -1, -1, false));	}
|	expression() < SEMI >
	{
	  Object l = stack.pop(); //clean off leftover stack
	}
|	< BREAK > < SEMI >
	{
	  Object nq = breakStack.pop();
	  breakStack.push(eQuadList.size());
	  eQuadList.add(new ExtendedQuad("jump",null,null,nq.toString(),-1));	}
|	< RET > expression() < SEMI >
	{
	  String a = stack.pop().toString();
	  eQuadList.add(new ExtendedQuad("RTS", a, null, null, -1));	}
|	< CONT > < SEMI >
	{
	  Object loc = contStack.pop();
	  contStack.push(loc);
	  eQuadList.add(new ExtendedQuad("jump", null, null, loc.toString(), -1));	}
|	< SEMI >}

void compound_statement() :
{}
{
	< LBRACE >
	{
	  offsetStack.push(offset);
	  blockStack.push("block"+(symbolCounter));	  symbolTable.add(new Symbol("block"+symbolCounter++,"block"+nestingLevel,++nestingLevel,-1,-1,-1));
	  offset = 0;
	}
	statement_list() < RBRACE >
	{	  nestingLevel--;
	  offset = (int) offsetStack.pop();
	  blockStack.pop();
	}
}

void statement_list() :
{}{
	statement() [ statement_list() ]}

void test() :
{}
{
	< LPAREN > expression() < RPAREN >}

void expression() :
{}{
  	LOOKAHEAD(2)
  	< ID >
  	{
  	  stack.push(getToken(0).image);
  	  stack.push(getToken(0).image);
  	  boolean add = true;
  	  Object block = blockStack.peek();
  	  for (Symbol s : symbolTable)
  	  {  	    if (s.getName().equals(getToken(0).image) && s.getBlock().equals(block.toString()))
  	    {  	      add = false;
  	      break;
  	    }
  	  }
  	  if (add)
  	  {
  	    symbolTable.add(new Symbol(getToken(0).image, block.toString(), nestingLevel, offset*4, -1, -1));
  	  	offset++;  	  }  	}
  	< EQ > expression()
  	{
  	  Object exp = stack.pop();
  	  Object des = stack.pop();
  	  eQuadList.add(new ExtendedQuad("copy", exp.toString(), null, des.toString(), -1));
  	}
|	fn_call()
}

void fn_call() :
{
  Token id, fn;
}
{
  	condition()
  	{
  	  fn = getToken(0);  	}
  	[ < LPAREN > [ id=< ID >
  	{	  for (Symbol s : symbolTable)
	  {		if (id.image.equals(s.getName()))
		{
		  eQuadList.add(new ExtendedQuad("push", id.image, null, "stack", -1));
		  return;		}
	  }
  	}
  	] < RPAREN > {
	  for (Symbol s : symbolTable)
	  {
		if (fn.image.equals(s.getName()))
		{
		  eQuadList.add(new ExtendedQuad("jsr", null, null, s.getLocations()+"", -1));
		}
	  }
  	}
  	]
  	
}

void condition() :
{}{	disjunction() [ < QMARK >
	{
	  Object o = stack.pop();
	  int nq1 = eQuadList.size();
	  eQuadList.add(new ExtendedQuad("jeqz", o.toString(), null, null, -1));
	  stack.push(nq1);	}
	expression()
	{
	  Object expr = stack.pop();
	  Object nq = stack.pop();
	  Object var = stack.pop();
	  eQuadList.add(new ExtendedQuad("copy", expr.toString(), null, var.toString(), -1));
	  stack.push(var);
	  stack.push(nq);	}
	< COLON >
	{
	  int nq2 = eQuadList.size();
	  eQuadList.add(new ExtendedQuad("jump", null, null, null, -1));
	  Object loc = stack.pop();
	  eQuadList.get((int) loc).setResult(new Field(eQuadList.size() + "", -1, -1, false));
	  stack.push(nq2);	}
	condition()
	{
	  Object b = stack.pop();
	  Object a = stack.pop();
	  Object c = stack.pop();
	  eQuadList.get((int) a).setResult(new Field((eQuadList.size()+1)+"",-1,-1,false));
	  stack.push(c);
	  stack.push(b);	}
	]
}

void disjunction() :
{}{
  	conjunction() disjunctionP()}

void disjunctionP() :
{}{
	[ < OR > conjunction()
	{
	  Object a = stack.pop();
	  Object b = stack.pop();
	  eQuadList.add(new ExtendedQuad("|", a.toString(), b.toString(), "temp"+tempCounter, -1));
	  stack.push("temp"+tempCounter++);
	}
	disjunctionP() ]}

void conjunction() :
{}
{
	comparison() conjunctionP()}

void conjunctionP() :
{}{
	[ < AND > comparison()
	{
	  Object a = stack.pop();
	  Object b = stack.pop();
	  eQuadList.add(new ExtendedQuad("&", a.toString(), b.toString(), "temp"+tempCounter, -1));
	  stack.push("temp"+tempCounter++);	}
	conjunctionP() ]}
void comparison() :
{}
{	relation() [ < DEQ > relation()
	{
	  Object a = stack.pop();
	  Object b = stack.pop();
	  eQuadList.add(new ExtendedQuad("==", a.toString(), b.toString(), "temp"+tempCounter, -1));
	  stack.push("temp"+tempCounter++);
	}
	]
}

void relation() :
{}{	sum() [ rel_op() sum()
	{
	  Object s1 = stack.pop();
	  Object op = stack.pop();
	  Object s2 = stack.pop();
	  eQuadList.add(new ExtendedQuad(op.toString(), s2.toString(), s1.toString(), "temp"+tempCounter, -1));
	  stack.push("temp"+tempCounter++);	}
	]
}  
void sum() :
{}{
	term() (sumP())*
}

void sumP() :
{}{
	add_op() term()
	{
	  Object op1 = stack.pop();
	  String operation = stack.pop().toString();
	  Object op2 = stack.pop();

	  eQuadList.add(new ExtendedQuad(operation, op1.toString(), op2.toString(), "temp"+tempCounter, -1));
	  stack.push("temp" + tempCounter++);
	}}

void term() :
{}
{	factor() (termP())*
}

void termP() :
{}
{	mul_op() factor()
	{
	  Object op1 = stack.pop();
	  String operation = stack.pop().toString();
	  Object op2 = stack.pop();

	  eQuadList.add(new ExtendedQuad(operation, op1.toString(), op2.toString(), "temp"+tempCounter, -1));
	  stack.push("temp"+tempCounter++);
	  
	}
}

void factor() :
{
  Object op = null;
}
{	unary_op() primary()
	{
	  Object p = stack.pop();
	  Object u = stack.pop();
	  if ("!".equals(u.toString()))
	  {
	    eQuadList.add(new ExtendedQuad("!", p.toString(), null, "temp"+tempCounter, -1));
		stack.push("temp"+tempCounter++);
	  }
	  else if ("-".equals(u.toString()))
	  {
	    eQuadList.add(new ExtendedQuad("u-", p.toString(), null, "temp"+tempCounter, -1));
	    stack.push("temp"+tempCounter++);
	  }	}
|	primary()
}

void primary() :
{}
{	< ID >
	{
	  stack.push(getToken(0).image);
	}
|	< INT >
	{
	  stack.push(Integer.valueOf(getToken(0).image));
	}
| 	< LPAREN > expression() < RPAREN >
}

void rel_op() :
{}{
	< LT >
	{
	  stack.push("<");
	}
| 	< GT >
	{
	  stack.push(">");
	}}

void mul_op() :
{}{
	< MULTIPLY >
	{
	  stack.push("*");
	}
| 	< DIVIDE >
	{
	  stack.push("/");
	}
| 	< MOD >
	{
	  stack.push("%");
	}}

void add_op() :
{}{
	< PLUS >
	{
	  stack.push("+");
	}
|	< MINUS >
	{
	  stack.push("-");
	}}

void unary_op() :
{}{
	< MINUS >
	{
	  stack.push("-");
	}
|	< NOT >
	{
	  stack.push("!");
	}}

JAVACODE
void errorSkipTo(int kind)
{
  ParseException e = generateParseException();
  System.out.println(e.toString());
  System.out.println("Nullifying current statement");
  Token t;
  do  {	t = getNextToken();
  } while  (t.kind != kind);
}

JAVACODE
void errorSkipBlock()
{
  ParseException e =  generateParseException();
  System.out.println(e.toString());
  System.out.println("Nullifying current statement");
  Token t;
  int kind = SEMI;
  do
  {
    t = getNextToken();
    if (t.kind == LBRACE)    {
      System.out.println("Removing WHILE-block");      kind = RBRACE;
    }
  } while(t.kind != kind);
}